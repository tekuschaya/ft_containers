List:
1. при assign (first, end) если список сначала очистить, то не работает (оригинал работает)


map
как перемещаться по const iter
как очистить мапу если она не создана и инициализируется оператором присваивания
не работает const iter в find


test.push_back(1);
test.push_back(2);
std::cout << *(--test.end()) << std::endl;
std::cout << *(test.end()) << std::endl;
последний элемент листа и end равны


ошибка max size в векторе и в деке при char


при добавлении Alloc в Tree нихера не работает

ошибка маллока при clear в операторе присваивания. Как понять, была ли уже создана мапа?

деструктор в мапе отрабатывает два раза (в дочернем и родительском)

to do:
1. переделать константные итераторы и InputIterator +
2. сделать аллокатор в векторе и деке
3. переделать дерево на красно черное +
4. pointer и reference через Allocator:: ?
5. ПРоверить в мапе --end()
6. queue и deque в одном файле? +
7. переписать reverse iterator один на всех +
8. capacity в векторе не совпадает с оригиналом
9. reverse iterator for map +
10. добавить из вершины дерева правую ссылку на максимальный элемент для end
11. Убрать везде nullptr
12. Понять почему max size char не совпадает
13. переделать color bool tree +
14.  если удалить this->end() map ???
15. дописать операторы к реверс итератору и проверить операторы для всех контейнеров +
16. Ошибка тест max size set и multiset 
17. не забыть вставить enable if  +
18. переделать сортировку на quick sort
19. прогнать тесты дена
20. проверить на утечки

21. переделать шаблоны вектора/мапы

СЕГА В ВЕКТОРЕ ИЗ ЗА АЛЛОКАТОРА





работа с аллокатором:

создаем в private allocator_type     _alloc

выделяем память на 2 элемента в массив _arr = _alloc.allocate(2);

Инициализируем массив где finish поинтер куда вставить и val значение

!!!!!!!!Val нужно умножать на sizeof(value_type) !!!!!!!!!!
for(size_type i = 0; i < n; i++)
{
	_alloc.construct(_finish, val);
	_size_vector++;
	_finish++;
}


здесь зачищаем память где указываем на первый элемент массива и количество вторым параметром
void clear ()
{
	if(_size_vector == 0)
		return ;
	else
	{
		_alloc.deallocate(_start, _last_cell_mem);
		_size_vector = 0;
		_last_cell_mem = 0;
	}
}


так мы можем убрать значение из массива, но при этом сохранить выделенную память
_alloc.destroy(_arr[i]);


